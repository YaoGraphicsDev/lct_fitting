cmake_minimum_required(VERSION 3.20)
project(LCTFit)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Recursively get all .cpp, .h, and .hpp files in third_party
file(GLOB THIRD_PARTY_SOURCES third_party/*.cpp third_party/*.c)
file(GLOB THIRD_PARTY_HEADERS third_party/*.h third_party/*.hpp)

# Your own project's source/header files (non-recursive or recursive as needed)
file(GLOB SOURCES *.cpp)
file(GLOB HEADERS *.h *.hpp)

# Combine everything
set(ALL_SOURCES ${SOURCES} ${HEADERS} ${THIRD_PARTY_SOURCES} ${THIRD_PARTY_HEADERS})

# Create the executable
add_executable(${PROJECT_NAME} ${ALL_SOURCES})

# third party
target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/third_party)

# Vulkan
find_package(Vulkan REQUIRED)
target_include_directories(${PROJECT_NAME} PRIVATE ${Vulkan_INCLUDE_DIRS})

# CLI11
set(CLI11_PATH "" CACHE PATH "Path to the directory containing CLI11.hpp")
if(NOT CLI11_PATH)
    message(FATAL_ERROR "CLI11_PATH not set.")
endif()
message(STATUS "Using CLI11.hpp.h path: ${CLI11_PATH}")
target_include_directories(${PROJECT_NAME} PRIVATE ${CLI11_PATH})

set(OUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/out")
file(MAKE_DIRECTORY "${OUT_DIR}")
# optional: pass to code
target_compile_definitions(${PROJECT_NAME} PRIVATE OUT_DIR=\"${OUT_DIR}\")


# set tinyexr path
#set(TINYEXR_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../tinyexr")
#message(STATUS "TINYEXR_PATH = ${TINYEXR_PATH}")
#target_include_directories(${PROJECT_NAME} PUBLIC ${TINYEXR_PATH})
#
## set miniz path, required by tinyexr
#set(MINIZ_PATH "${CMAKE_CURRENT_SOURCE_DIR}/../miniz")
#message(STATUS "MINIZ_PATH = ${MINIZ_PATH}")
#target_include_directories(${PROJECT_NAME} PUBLIC ${MINIZ_PATH})